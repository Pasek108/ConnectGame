"use strict";class BridgesUtils{constructor(){}static createEmptyLevelArray(t,e){const l=[];for(let n=0;n<=e;n++){l.push([]);for(let e=0;e<=t;e++)l[n].push(0)}return l}static getAdjacentIslands(t,e,l){const n=t.length,o=t[0].length,s=[null,null,null,null];for(let n=e-1;n>=0;n--)if(null!=t[n][l]&&t[n][l].active){s[0]=t[n][l];break}for(let n=l+1;n<o;n++)if(null!=t[e][n]&&t[e][n].active){s[1]=t[e][n];break}for(let o=e+1;o<n;o++)if(null!=t[o][l]&&t[o][l].active){s[2]=t[o][l];break}for(let n=l-1;n>=0;n--)if(null!=t[e][n]&&t[e][n].active){s[3]=t[e][n];break}return s}static isNewBridgeCrossing(t,e,l){const n=t.length,o=t[0].length;let s=[0,0],i=[0,0];for(let r=0;r<n;r++)for(let n=0;n<o;n++)t[r][n]===e&&(s=[r,n]),t[r][n]===l&&(i=[r,n]);let r=[],a=[];s[0]<i[0]||s[1]<i[1]?(r=s,a=i):(r=i,a=s);let c=+!(r[1]===a[1]);for(let e=r[c]+1;e<a[c];e++){const l=0===c?e:r[0],n=0===c?r[1]:e,o=this.getAdjacentIslands(t,l,n);for(let t=0;t<4;t++)if(null!=o[t]&&(t===1-c||t===3-c)&&0!==o[t].connections[(t+2)%4])return!0}return!1}static setAdjacentBridgesSizes(t,e){const l=t.getPosition();for(let n=0;n<4;n++){if(null==e[n])continue;const o=e[n].getPosition();l.left===o.left?l.top<o.top?e[n].setTopBridgeSize(l):t.setTopBridgeSize(o):l.left<o.left?e[n].setLeftBridgeSize(l):t.setLeftBridgeSize(o)}}static getClosestIslandAndFocusBridge(t,e,l,n){const o=e.getPosition();let s=[Math.abs(o.bottom-n[0]+window.scrollY),Math.abs(o.left-n[1]+window.scrollX),Math.abs(o.top-n[0]+window.scrollY),Math.abs(o.right-n[1]+window.scrollX)],i=s[0],r=0;for(let t=1;t<4;t++)s[t]>i&&(i=s[t],r=t);e.unfocusTop(),e.unfocusLeft(),null!=l[1]&&l[1].unfocusLeft(),null!=l[2]&&l[2].unfocusTop();for(let n=0;n<4;n++)if(null!=l[n]&&n===r&&i>1.3*e.container.offsetWidth){if(this.isNewBridgeCrossing(t,e,l[n]))break;switch(n){case 0:e.focusTop();break;case 1:l[n].focusLeft();break;case 2:l[n].focusTop();break;case 3:e.focusLeft()}return l[n]}return e}static addBridgeBetweenIslands(t,e){const l=t.getPosition(),n=e.getPosition();l.left===n.left?l.top<n.top?(e.addBridgeTop(),t.changeConnection(2)):(t.addBridgeTop(),e.changeConnection(2)):l.left<n.left?(e.addBridgeLeft(),t.changeConnection(1)):(t.addBridgeLeft(),e.changeConnection(1))}static generateBridgesLevel(t,e){let l=this.createEmptyLevelArray(t,e),n=[];for(let l=0;l<=e;l++){n.push([]);for(let e=0;e<=t;e++)n[l].push([0,0,0,0])}let o=[GlobalUtils.randomInt(0,e),GlobalUtils.randomInt(0,t)];for(let s=0;s<=1e3;s++)for(let s=0;s<=1e3;s++){const s=GlobalUtils.randomInt(0,3),i=s%2?GlobalUtils.randomInt(1,e-o[0]+1):GlobalUtils.randomInt(1,t-o[1]+1);let r=o[s%2];for(let n=1;n<=i;n++){const a=[-n,n,n,-n],c=[e,t];if(o[s%2]+a[s]<0){r=0;break}if(o[s%2]+a[s]>c[s%2]){r=c[s%2];break}if(l[o[0]+a[s]*((s+1)%2)][o[1]+a[s]*(s%2)]>0){r=o[s%2]+a[s];break}if(n===i){r=o[s%2]+a[s];break}}if(r!==o[s%2]){const i=[o[0],o[1]],a=n[o[0]][o[1]];if(2===a[s])continue;o[s%2]=r;const c=n[o[0]][o[1]];let f=!1;if(0===l[o[0]][o[1]]){if(this.isNewBridgeCrossing(l,n,t,e,a,c))continue;const i=this.getAdjacentIslands(l,n,o[0],o[1]);null!==i[0]&&null!==i[2]&&i[0][2]>0&&i[2][0]>0&&(c[0]=i[0][2],c[2]=i[2][0],s%2==0&&(f=!0)),null!==i[1]&&null!==i[3]&&i[1][3]>0&&i[3][1]>0&&(c[1]=i[1][3],c[3]=i[3][1],s%2==1&&(f=!0))}f||(a[s]=(a[s]+1)%3),l[i[0]][i[1]]=a.reduce(((t,e)=>t+e)),f||(c[(s+2)%4]=(c[(s+2)%4]+1)%3),l[o[0]][o[1]]=c.reduce(((t,e)=>t+e))}}return l}}